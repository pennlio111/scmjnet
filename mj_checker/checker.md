# 和牌判断器

从听牌判断-算番-和牌开始

objective: MVP 判断14张手牌是否和牌

input: 14张手牌 1-9m1-9p1-9s1-7z
p:
o: 是否和牌, 和牌的面子和雀头

## 算法

先做标准形: 四面子一雀头

排序后的手牌: 占用或未占用

先只接受四顺子一雀头

思路: 

1. 手牌都未占用
2. 从第一张牌开始填坑; 第一个顺子第一张, 第二张, 第三张;
3. 从第一张牌开始循环, 寻找未占用手牌, 填下个面子.

改写为用循环不断循环搜索面子:

- i, j, k 为三个不断递增的循环变量
- 用一个 flag 表示当前牌是否已经被使用
- 不断递增循环变量, 每组成一个面子就标记三张牌为已用

最终思路: 迭代

- 目标: 从n张牌形成i个面子和j个雀头 (14-4-1)
- 循环完成一个面子或者一个雀头(算法: 先尝试雀头, 如果不能完成, 则一定是面子)
- 完成时, 用上面提到的i j k三个变量表示当前的2/3张牌, 不断递增.
- 迭代n-2/n-3张牌到i/i-1个面子和j-1/j个雀头
- 迭代到只剩2/3张牌时, 即可判断是否能完成.


commit 5b03652: basic logic 可用
可识别不互相牵扯的几个面子.

to do:

- 把 flag 改写为一个类, 比列表容易理解
  - finished
- 加入雀头基本逻辑判断
- 补充逻辑判断
  - 目前在112233型判断有误, 第二张牌的循环体有问题, 没有正确循环过去
- input: 写处理函数, 把形如 123m456789s 的手牌整理为一个手牌列表, 便于测试
  - finished

## 小结 commit 938374
1. 算法很重要
2. 使用OOP实现, 希望具有更好的扩展性.
  - 注意OOP中init不支持胡乱赋值
  - 错误信息处理目前靠建立一个判断方法(isvalid) 实现
  - 希望在后续向听数和番种计算时,OOP可起到帮助抽象的作用.
3. i/o
  - 使用`try...except`同时在argv和input接受数据输入.

## 非标准型的判断
1. 七对子: 和牌排序后, 必然两两相同, 循环迭代即可
2. 十三幺: 先生成所有13种牌型, 依次比较.

# api commit c87991

`def hand_processer(raw_hand, length=VALID_LENGTH_OF_HAND, check_input=False)`

返回用 Card 类表示的手牌(已排序)

`def mahjong_checker(raw_hand, output_notes=True)`

判断 raw_hand 是否为和牌型

